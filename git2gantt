#!/usr/bin/env python3
"""Simple tool to turn git commit histories into a mermaid gantt chart."""

##############################################################################
# Module information.
__author__     = "Dave Pearson"
__copyright__  = "Copyright 2019, Dave Pearson"
__licence__    = "GPL"
__credits__    = [ "Dave Pearson" ]
__maintainer__ = "Dave Pearson"
__email__      = "davep@davep.org"
__version__    = "0.0.1"

##############################################################################
# Imports.
import os
import sys
import argparse
import subprocess
from pathlib  import Path
from datetime import datetime
from datetime import timedelta

##############################################################################
# Exception for signifying that there's no such repo.
class NoSuchRepo( FileNotFoundError ):
    """No such repository error."""

class NotAGitRepo( Exception ):
    """Directory exists but isn't a git repository."""

##############################################################################
# Tidy up a repository.
def tidy_repo( repo ):
    """Tidy the details of the given repository.

    :param str repo: A path to a possible repository.
    :returns: A fully-qualified path to the repository.
    :rtype: Path
    :raises: Exception TODO
    """

    # Wrap it up as a path object.
    repo = Path( repo )

    # Does it exist?
    if not repo.exists():
        raise NoSuchRepo( "{} does not exist".format( str( repo ) ) )

    # Does it look like an actual git repository?
    if not ( repo / ".git" ).exists():
        raise NotAGitRepo(
            "{} does not look like a git repository".format( str( repo ) )
        )

    # Return the fully-qualified path.
    return repo.resolve()

##############################################################################
# Tidy up the repository list.
def tidy_repos( repos ):
    """Tidy the repository list, and also check they're all good.

    :param list repos: A list of repository paths to work from.
    :returns: A tidy list of repositories.
    :rtype: list
    :raises: Exception TODO

    Note that this function takes each of the repository paths and turns
    them into a Path object, ensuring that they exist and look like a git
    repository along the way.
    """
    return [ tidy_repo( repo ) for repo in repos ]

##############################################################################
# Turn a string date into a date/time value.
def _str_to_date( string_date ):
    """Convert a string date into a date value.

    :param str string_date: A string date in YYYY-MM-DD format.
    :returns: A date value.
    :rtype: datetime
    """
    return datetime.strptime( string_date, "%Y-%m-%d" )

##############################################################################
# Get the history of the given repository.
def get_history( repo ):
    """Get the history of the given repository.

    :param Path repo: A path to a repository.
    :returns: A list of commit dates for the repository.
    :rtype: list
    """

    # Go to the repo.
    os.chdir( str( repo ) )

    # Get the repo history from git.
    log, error = subprocess.Popen( [
        "git", "log", "--date=iso8601-strict", '--pretty=format:%ad'
    ], stdout=subprocess.PIPE, universal_newlines=True ).communicate()

    # Return a sorted list of unique dates that there's been commits to the repo.
    return sorted(
        list( set( [ _str_to_date( date[ 0:10 ] ) for date in log.splitlines() ] ) )
    )

##############################################################################
# Get the command line params.
def get_args():
    """Parse the command line parameters.

    :returns: The parsed command line arguments.
    :rtype: Namespace
    """

    # Create the argument parser object.
    parser = argparse.ArgumentParser(
        description = "git history to mermaid gantt chart tool",
        epilog      = "v{}".format( __version__ )
    )

    # Add --version
    parser.add_argument(
        "-v", "--version",
        help    = "Show version information.",
        action  = "version",
        version = "%(prog)s v{}".format( __version__ )
    )

    # The remainder is the files to check.
    parser.add_argument( "repos", nargs = argparse.REMAINDER )

    # Parse the command line.
    return parser.parse_args()

##############################################################################
# Figure out the next working day of a given day.
def _next_working_day( day ):
    """Return the date of the next working day.

    :param datetime day: The day to get the next working day from.
    :returns: The date of the next working day.
    :rtype: datetime

    Note that this function makes a lot of assumptions about what a working
    day is and how to get to it. This works for me. If anyone else needs to
    make use of this and their idea of a working day differs it would make
    sense to make this function far more flexible.
    """
    return day + timedelta( days={
        0: 1,                   # Monday
        1: 1,                   # Tuesday
        2: 1,                   # Wednesday
        3: 1,                   # Thursday
        4: 3,                   # Friday
        5: 2,                   # Saturday
        6: 1,                   # Sunday
    }[ day.weekday() ] )

##############################################################################
# Convert a repo's history into a list of start days and sessions lengths.
def contiguous_days( history ):
    """Convert a repository's history into a list of sessions and length.

    :param list history: The history of commit days.
    :returns: A list of start days and session length.
    :rtype: list
    """

    # Start with the first day in the history.
    days = { history[ 0 ] : 1 }

    # Get the initial session start date.
    session_start_day = history[ 0 ]

    # Working through the history, looking at "yesterday" and "today"...
    for yesterday, today in zip( history, history[ 1: ] ):
        # If it's a contiguous working day...
        if _next_working_day( yesterday ) == today:
            # ...count it as being part of the same development session.
            days[ session_start_day ] = days.get( session_start_day, 1 ) + 1
        else:
            # It's not contiguous. Consider it a new session.
            session_start_day = today

    # Return the result.
    return days

##############################################################################
# Emit the mermaid code for the repository.
def emit_repo( name, history ):
    """Emit the mermaid code for the given repository.

    :param str name: The name of the repository.
    :param list history: The history of commit days for the given repository.
    """

    # Start the section for the repo.
    print()
    print( "  section {}".format( name ) )

    # Print out the coding sessions.
    for start_day, days in contiguous_days( history ).items():
        print( "  {}: {}, {}, {}d".format(
            "Development work",
            "dev{}{}".format( name, start_day.strftime( "%Y%m%d" ) ),
            start_day.strftime( "%Y-%m-%d" ),
            days
        ) )

##############################################################################
# Emit the mermaid code for the repositories.
def emit_mermaid( repos ):
    """Emit the mermaid code for the given repositories.

    :param dict repos: Dictionary of repositories.
    """

    # Print the header of the diagram.
    print( "gantt" )
    print( "  title git2gantt output")
    print( "  dateFormat YYYY-MM-DD" )

    # Emit each of the repos.
    for repo, history in repos.items():
        emit_repo( repo, history )

##############################################################################
# Main code.
def main():
    """Main entry point."""

    # Get the arguments.
    args = get_args()

    try:

        # Tidy up all the repo pointers, and ensure they're all good.
        args.repos = tidy_repos( args.repos )

    except ( NoSuchRepo, NotAGitRepo ) as error:
        print( error )
        sys.exit( 1 )

    # Emit the gantt diagram from the commit histories.
    emit_mermaid( {
        repo.parts[ -1 ]: get_history( repo ) for repo in args.repos
    } )

##############################################################################
# Main entry point.
if __name__ == "__main__":
    main()

### git2gantt ends here
